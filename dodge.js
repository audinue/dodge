// Generated by CoffeeScript 2.7.0
(function() {
  var Label, NewGame, Rect, draw, init, intersect, start, tick;

  Rect = function(props) {
    return {
      tag: 'Rect',
      x: 0,
      y: 0,
      width: 10,
      height: 10,
      color: 'black',
      ...props
    };
  };

  Label = function(props) {
    return {
      tag: 'Label',
      x: 0,
      y: 0,
      color: 'black',
      text: '',
      align: 'center',
      vAlign: 'middle',
      ...props
    };
  };

  start = function(init, tick, draw) {
    var load;
    load = function() {
      var animate, canvas, config, ctx, input, inputMap, state;
      canvas = document.createElement('canvas');
      ctx = canvas.getContext('2d');
      config = {
        width: canvas.width,
        height: canvas.height
      };
      state = init(config);
      input = {
        left: false,
        right: false,
        enter: false
      };
      inputMap = {
        ArrowLeft: 'left',
        ArrowRight: 'right',
        Enter: 'enter'
      };
      window.onkeydown = function(e) {
        if (e.key in inputMap) {
          return input = {
            ...input,
            [`${inputMap[e.key]}`]: true
          };
        }
      };
      window.onkeyup = function(e) {
        if (e.key in inputMap) {
          return input = {
            ...input,
            [`${inputMap[e.key]}`]: false
          };
        }
      };
      document.body.append(canvas);
      animate = function() {
        var i, len, node, output;
        state = tick(config, state, input);
        output = draw(config, state);
        ctx.fillStyle = '#eee';
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (i = 0, len = output.length; i < len; i++) {
          node = output[i];
          switch (node.tag) {
            case 'Rect':
              ctx.fillStyle = node.color;
              ctx.fillRect(node.x, node.y, node.width, node.height);
              break;
            case 'Label':
              ctx.fillStyle = node.color;
              ctx.textAlign = node.align;
              ctx.textBaseline = node.vAlign;
              ctx.fillText(node.text, node.x, node.y);
          }
        }
        return requestAnimationFrame(animate);
      };
      return requestAnimationFrame(animate);
    };
    if (document.readyState === 'interactive') {
      return load();
    } else {
      return addEventListener('DOMContentLoaded', load);
    }
  };

  intersect = function(a, b) {
    return a.x <= b.x + b.width && b.x <= a.x + a.width && a.y <= b.y + b.height && b.y <= a.y + a.height;
  };

  NewGame = function(config) {
    return {
      tag: 'Game',
      player: Rect({
        x: (config.width - 10) / 2,
        y: config.height - 30,
        color: 'blue'
      }),
      enemies: [],
      counter: 0,
      score: 0
    };
  };

  init = function() {
    return {
      tag: 'Title'
    };
  };

  tick = function(config, state, input) {
    switch (state.tag) {
      case 'Title':
      case 'GameOver':
        if (input.enter) {
          return NewGame(config);
        } else {
          return state;
        }
        break;
      case 'Game':
        if (state.enemies.some(function(enemy) {
          return intersect(enemy, state.player);
        })) {
          return {
            tag: 'GameOver',
            score: state.score
          };
        } else {
          return {
            tag: 'Game',
            player: {
              ...state.player,
              x: input.left && state.player.x > 0 ? state.player.x - 5 : input.right && state.player.x < config.width - 10 ? state.player.x + 5 : state.player.x
            },
            enemies: (state.counter === 20 ? [
              ...state.enemies,
              Rect({
                x: Math.floor(Math.random() * (config.width - 10)),
                y: -10,
                color: 'red'
              })
            ] : state.enemies).map(function(enemy) {
              return {
                ...enemy,
                y: enemy.y + 5
              };
            }).filter(function(enemy) {
              return enemy.y <= config.height;
            }),
            counter: state.counter === 20 ? 0 : state.counter + 1,
            score: state.score + (state.enemies.filter(function(enemy) {
              return enemy.y >= config.height;
            })).length
          };
        }
    }
  };

  draw = function(config, state) {
    switch (state.tag) {
      case 'Title':
        return [
          Label({
            text: 'Dodge',
            x: config.width / 2,
            y: config.height / 2 - 10
          }),
          Label({
            text: 'Press enter to play',
            x: config.width / 2,
            y: config.height / 2 + 10
          })
        ];
      case 'Game':
        return [
          state.player,
          ...state.enemies,
          Label({
            text: state.score,
            x: 10,
            y: 10,
            align: 'left',
            vAlign: 'top'
          })
        ];
      case 'GameOver':
        return [
          Label({
            text: 'Game Over',
            x: config.width / 2,
            y: config.height / 2 - 20
          }),
          Label({
            text: `Score: ${state.score}`,
            x: config.width / 2,
            y: config.height / 2
          }),
          Label({
            text: "Press enter to play again",
            x: config.width / 2,
            y: config.height / 2 + 20
          })
        ];
    }
  };

  start(init, tick, draw);

}).call(this);
